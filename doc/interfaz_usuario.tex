\chapter{Desarrollo de la interfaz de usuario}
En Ingeniería del Software nos enseñaron que para añadir una interfaz de usuario a un sistema ya hecho no había que modificar el sistema ya existente. Hay metodologías que empiezan haciendo una interfaz de usuario ``vacía'' y, a partir de ahí, van añadiéndole funcionalidad a sus botones. En nuestro caso hemos optado por el primer principio, ya que nos pareció la forma más natural de hacerlo. A continuación, explicaré cómo hice para conectar la aplicación web que he desarrollado como interfaz de usuario con el programa \texttt{Python} que calcula el horario.

\section{Diseño de la interfaz}
Antes de empezar a programar, estuve pensando cómo debería ser la interfaz. Mi objetivo era hacerla lo más sencilla posible. Lo ideal hubiese sido que el programa funcionase simplemente con pulsar un botón, pero por desgracia tuve que ponerle algunas cosas más debido a su complejidad.

En primer lugar, diseñé una primera pantalla de bienvenida en la que se le solicititaban al usuario los datos necesarios para hacer el horario: días, horas y cuatrimestre. No quise añadir nada más a esta pantalla para hacerlo lo más sencillo posible. En la \hyperref[init]{Figura \ref*{init}} se puede ver un esquema sencillo de esta idea. Es un simple formulario con tres campos y un botón para subir dichos datos al servidor. ¿Para qué más?

\begin{figure}
\centering
\scalebox{.7}{\input{img/pantalla_inicial.tex}}
\caption{Pantalla inicial del programa}
\label{init}
\end{figure}

Después, diseñé la pantalla en la que se presentaría el horario final al usuario. En este caso, quise que el horario fuera lo más importante de la pantalla y el elemento que ocupase toda la atención. Para cambiar entre los horarios de cada grupo, decidí poner un menú \textit{dropdown}, pues era lo más disimulado. Me pareció que un sidebar ocupaba demasiado espacio y, un sidebar que se oculta y se muestra dinámicamente me pareció poco intuitivo. También añadí un botón para exportar el horario a PDF. En la \hyperref[horario]{Figura \ref*{horario}} se puede ver un esquema de esta pantalla.

\begin{figure}
\centering
\scalebox{.6}{\input{img/pantalla_horario.tex}}
\caption{Pantalla para mostrar el horario en el programa}
\label{horario}
\end{figure}

\section{Herramienta usada}
Actualmente, hay un montón de tecnologías o herramientas para hacer todo tipo de interfaces de usuario. Me limité a buscar herramientas para \texttt{Python}, pues así podía integrar de forma muy sencilla todo el trabajo previo ya realizado en este lenguaje. Si hubiese usado otras herramientas, tendría que haber un puente para intercambiar información entre ambas, lo que podría suponer un cuello de botella. Por ejemplo, para conectar Python con un servidor NodeJS, se tienen que hacer JSON que reciben como parámetro y devuelven ambas partes para intercambiar información. Hay herramientas en el mercado que están así implementadas, como por ejemplo, la Restful API de Wazuh (\url{https://github.com/wazuh/wazuh-api}). 

A la hora de hacer una interfaz de usuario en \textit{Python} tenía dos opciones: o bien hacer una interfaz usando \texttt{PyQt} (\url{https://wiki.python.org/moin/PyQt}) o bien hacer una \textit{aplicación web}. Finalmente, me decanté por hacer una aplicación web por las varias razones. En primer lugar, una aplicación web \textit{responsive} puede usarse tanto desde un teléfono móvil como desde un ordenador. Además, el uso de una aplicación web permite que varias personas trabajen a la vez sobre la misma usando una base de datos centralizada, en lugar de tener una copia de los datos en cada ordenador. Otra ventaja de hacer una aplicación web es que el programador se puede abstraer del sistema operativo, ya que se ejecutará en un navegador. Así, en lugar de hacer una aplicación para cada sistema operativo, sólo se hace una que se dejará ejecutando en un servidor y a la que los usuarios accederán desde su PC. Lo único que debe preocupar al programador es el navegador que se use, sobre todo si algún usuario aún sigue usando \textit{Internet Explorer}.

Cuando ya decidí qué tipo de interfaz de usuario haría, pasé a pensar con qué \textbf{herramienta} iba a hacerla. Estuve pensando en \texttt{Flask} (\url{http://flask.pocoo.org/}), pero finalmente lo descarté porque es un \textit{framework} que se usa (o se debería de usar) para hacer aplicaciones sencillas. De hecho, su eslogan es \textit{A Python Microframework}. A parte de esto, su documentación es un poco pobre. También estuve pensando en \texttt{Django} (\url{https://www.djangoproject.com/}). \texttt{Django} es fácilmente escalable, con sólo cambiar una línea en un fichero de configuración y hacer algún que otro pequeño ajuste más podemos pasar de usar \texttt{SQLite3} a usar \texttt{PostgreeSQL}, es decir, podemos pasar de usar un gestor de base de datos de ``juguete'' a uno muy potente. Además, tiene una documentación buenísima que incluye un montón de ejemplos ya hechos, además de un montón de explicaciones con muchísimo detalle. Y no solo eso, tiene además una comunidad enorme detrás, por lo que cualquier problema que surja estará resuelto en internet con bastante probabilidad.

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{img/django_flask_trends}
\caption{Interés sobre \texttt{Django} (en azul) y sobre \texttt{Flask} a lo largo del último año en todo el mundo. Datos: Google Trends (\url{https://g.co/trends/CgxUq})}
\label{djangoflasktrends}
\end{figure}

De hecho, si consultamos los datos ofrecidos por \textit{Google Trends} (\hyperref[djangoflasktrends]{Figura \ref*{djangoflasktrends}}) podemos ver que \texttt{Django} es mucho más popular que \texttt{Flask}. Esta es una razón más para elegir uno sobre el otro. ¿Por qué? Porque si un \textit{framework} es popular, significa que tendrá una comunidad que lo mantendrá y dará soporte durante mucho más tiempo. 

\subsection{Django}
\subsubsection{Instalación}
Para instalar \texttt{Django}, lo único que tenemos que hacer es ejecutar el siguiente comando:

\begin{minted}{shell-session}
$ sudo pip install django
\end{minted}

O, si sólo queremos instalar \texttt{Django} de forma local al proyecto y no en nuestro sistema, podemos crear un \texttt{\textit{virtualenv}} (\url{https://virtualenv.pypa.io/en/stable/}). Con esto, evitamos tener nuestro sistema lleno de paquetes que sólo hemos usado para una cosa concreta. Además, también nos da más flexibilidad, pues nos permite tener instalada una versión concreta de un paquete y evita colisiones entre paquetes. 

Al igual que \texttt{Django}, \texttt{virtualenv} se instala desde \texttt{pip}:

\begin{minted}{shell-session}
$ sudo pip install virtualenv
[sudo] password for marta: 
Collecting virtualenv
  Downloading virtualenv-15.1.0-py2.py3-none-any.whl (1.8MB)
    100% |================================| 1.8MB 374kB/s 
Installing collected packages: virtualenv
Successfully installed virtualenv-15.1.0
\end{minted}

Una vez instalado, para crear un \texttt{virtualenv} en la carpeta de nuestro proyecto ejecutamos el siguiente comando:

\begin{minted}{shell-session}
$ virtualenv ENV
Using base prefix '/usr'
New python executable in ENV/bin/python
Installing setuptools, pip, wheel...done.
\end{minted}

Donde \texttt{ENV} es la carpeta en la que queremos crear el \texttt{virtualenv}. 

Una vez creado, veremos los siguientes directorios:

% \begin{minted}{shell-session}
% $ ls -l
% total 16
% drwxr-xr-x 2 marta marta 4096 sep  5 19:57 bin
% drwxr-xr-x 2 marta marta 4096 sep  5 19:57 include
% drwxr-xr-x 3 marta marta 4096 sep  5 19:57 lib
% -rw-r--r-- 1 marta marta   60 sep  5 19:57 pip-selfcheck.json
% \end{minted}

\begin{enumerate}[---]
\item Los directorios \texttt{lib} e \texttt{include} contienen librerías que instalamos en el \texttt{virtualenv}. Recién creado, sólo contienen el intérprete de \texttt{python}.
\item El directorio \texttt{bin} guarda los ejecutables tantp de los paquetes que instalaremos en el \texttt{virtualenv} como los ejecutables que necesita \texttt{virutalenv} para funcionar.
\end{enumerate}

Un \texttt{virtualenv} recién creado necesita ser activado. Para ello, ejecutamos:

\begin{minted}{shell-session}
$ source bin/activate
\end{minted}

Nada más ejecutarlo, se modificará el shell para indicarnos que estamos dentro del \texttt{virtualenv}. Si queremos ``salir'' del mismo, basta con ejecutar:

\begin{minted}{shell-session}
$ deactivate
\end{minted}

Y volveremos a nuestra shell normal.

Volviendo a la instalación de \texttt{Django}, ahora que tenemos nuestro \texttt{virtualenv} listo podemos instalar \texttt{Django} sin usar sudo:

\begin{minted}{shell-session}
$ pip install Django
Collecting Django
  Downloading Django-1.11.5-py2.py3-none-any.whl (6.9MB)
    100% |=================================| 7.0MB 152kB/s 
Collecting pytz (from Django)
  Downloading pytz-2017.2-py2.py3-none-any.whl (484kB)
    100% |=================================| 491kB 788kB/s 
Installing collected packages: pytz, Django
Successfully installed Django-1.11.5 pytz-2017.2
\end{minted}

Para comprobar que \texttt{Django} se ha instalado correctamente, usamos el siguiente comando:

\begin{minted}{shell-session}
$ python -m django --version
1.11.5
\end{minted}

\subsubsection{Creando un proyecto}
Una de las cosas que más me gusta de \texttt{Django}, es que él solo automatiza un montón de tareas. Así, como ellos mismos dicen en su documentación, el programador puede centrarse en programar única y exclusivamente. Con otros \textit{framework} tendría que estar todo un día preparando un entorno de desarrollo antes de poder ponerme manos a la obra, en cambio, lo único que tengo que hacer es ejecutar el siguiente comando:

\begin{minted}{shell-session}
$ django-admin startproject NOMBRE
\end{minted}

donde \texttt{NOMBRE} es el nombre que queremos darle a nuestro proyecto.

Este comando nos crea toda la estructura de directorios necesaria para empezar a trabajar. Dicha estructura es la que se ve en la \hyperref[djangoprojectfolders]{Figura \ref*{djangoprojectfolders}}.

\begin{figure}
\centering
\scalebox{.7}{\input{img/django_project_folders.tex}}
\caption{Estructura de directorios inicial de Django}
\label{djangoprojectfolders}
\end{figure}

\begin{enumerate}[---]
	\item El directorio raíz \texttt{djangoapp} es sólo un contenedor del proyecto. Se puede cambiar de nombre sin ningún problema.
	\item El script \texttt{manage.py} nos permitirá gestionar nuestro proyecto: con él crearemos las apps que compondrán el proyecto, crearemos el superusuario que gestiona la base de datos, gestionaremos la base de datos, podemos acceder a un shell de \texttt{Django}, incluye un servidor pequeño (y que sólo debe usarse en desarrollo) y un montón de cosas más. Es uno de los archivos más importantes del proyecto.
	\item El directorio interior \texttt{djangoapp} es el paquete Python del proyecto.
	\item El fichero \texttt{djangoapp/\_\_init\_\_.py} es simplemente un archivo para que Python considere ese directorio como un paquete.
	\item El fichero \texttt{djangoapp/settings.py} contiene la configuración del proyecto. Por ejemplo, en este fichero se puede configurar el gestor de base de datos que se utilizará.
	\item El fichero \texttt{djangoapp/urls.py} contiene las declaraciones en forma de expresión regular de las URLs del proyecto. Estas URLs son las que se utilizarán para acceder a cada uno de los componentes del proyecto desde el navegador.
	\item El fichero \texttt{djangoapp/wsgi.py} contiene un punto de entrada para servidores web compatibles con WSGI para servir el proyecto django.
\end{enumerate}

Para asegurarnos de que el proyecto se ha creado correctamente, ejecutamos el siguiente comando:

\begin{minted}{shell-session}
$ python manage.py runserver
Performing system checks...

System check identified no issues (0 silenced).

You have 13 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.

September 05, 2017 - 19:09:31
Django version 1.11.5, using settings 'djangoapp.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
\end{minted}

Al acceder desde el navegador a la url \texttt{http://127.0.0.1:8000}, veremos la panatalla de la \hyperref[djangook]{Figura \ref*{djangook}}.

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{img/djangook}
\caption{¡Hola mundo! en Django}
\label{djangook}
\end{figure}

El comando \texttt{runserver} ejecuta un servidor de desarrollo escrito en Python. Gracias a esto, el desarrollador puede centrarse en desarrollar la aplicación sin tener que estar lidiando con la configuración de un servidor de producción. Ahora bien, este servidor sólo debe usarse para desarrollo. Una ventaja de este servidor es que se reinicia sólo cuando se modifica el código Python. Una comodidad más para el programador.

\section{Creando la aplicación de horarios}
Una vez tenemos nuestro proyecto creado, es hora de crear la aplicación que se encargará de comunicarse con el módulo Python que hace los horarios. El lector puede preguntarse, ¿cuál es la diferencia entre una app y un proyecto? Una app debe implementar una funcionalidad pequeña (por ejemplo, crear un horario) mientras que un proyecto encapsula varias apps bajo una determinada configuración. Sí, una app \texttt{Django} se puede usar en varios proyectos sin ningún problema.

Al igual que para crear el proyecto, \texttt{Django} ofrece un comando para crear apps:

\begin{minted}{shell-session}
$ python manage.py startapp timetables
\end{minted}

Se puede crear la app en cualquier directorio, aunque por sencillez, yo la creé justo en el mismo directorio que \texttt{manage.py}. Al crear la app, \texttt{Django} crea automáticamente la siguiente estructura de directorios de la \hyperref[djangoappfolders]{Figura \ref*{djangoappfolders}}.

\begin{figure}
\centering
\scalebox{.7}{\input{img/django_app_folders.tex}}
\caption{Estructura de directorios inicial de una aplicación Django}
\label{djangoappfolders}
\end{figure}

Una vez hemos creado nuestra app, es muy importante añadirla a la configuración de nuestro proyecto y que éste sepa que nuestra app existe. Para ello, sólo tenemos que modificar el fichero \texttt{djangoapp/settings.py} y añadir nuestra app a la lista \texttt{INSTALLED\_APPS}:

\newpage
\begin{minted}{python}
INSTALLED_APPS = [
    'timetables.apps.TimetablesConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
\end{minted}

Ya lo tenemos todo preparado para empezar a trabajar en nuestra app.

\subsection{Definiendo los modelos}
\begin{figure}
\centering
\scalebox{.7}{\input{img/database_models.tex}}
\caption{Estructura de tablas en la base de datos}
\label{djangomodels}
\end{figure}

En la \hyperref[djangomodels]{Figura \ref*{djangomodels}} podemos ver el modelo de de base de datos que he diseñado. El diseño que muestro es el de tablas SQL final, pero del diseño a la implementación en \texttt{Django} hay algunas cosas que cambian, ya que \texttt{Django} dispone de un \textit{Object-Relational Mapping} (ORM) \cite{orm}. Un \textit{Object-Relational Mapping} es una herramienta que convierte clases de objectos en tablas SQL. Así, nos abstraemos del concepto de tabla y la concebimos e implementamos como objetos. Por debajo, el \textit{Object-Relational Mapping} crea las tablas y relaciones SQL.

Respecto al modelo de bases de datos definido, la verdad es que no lo tuve muy difícil: he hecho una tabla para cada tipo de dato que almacenábamos en CSV antes de hacer la interfaz.

\begin{enumerate}[---]
    \item \textbf{Asignatura}: en este modelo, guardo todos los datos relativos a una asignatura, y además, las clases de prácticas en las que una asignatura puede impartirse.

Todos los campos son campos SQL normales, menos la relación con el de clases. El campo en el que guardo las clases en las que puede impartirse una asignatura es un campo especial de \texttt{Django} llamado \texttt{ManyToManyField}. Este campo es, por así decirlo, una lista de \textit{foreign keys} a la tabla \texttt{Classroom}. En el SQL normal es imposible hacer algo así, de hecho, \textbf{rompe la primera forma normal} en la normalización de bases de datos: cada campo debe tener un único valor (no una lista). Entonces, ¿cómo es esto posible? En realidad \texttt{Django} no está tan mal hecho como para hacer bases de datos con mala calidad. Cuando le especificamos a \texttt{Django} que haga un \texttt{ManyToManyField}, crea por debajo una nueva tabla en la que guardar dicha relación.

    \item \textbf{Clase}: en este modelo, guardo todos los datos relativos a un aula. Aunque en el modelo de clases Python inicial se separó entre clase de prácticas y clase de teoría, no tenía tanto sentido hacer esta separación en el modelo de base de datos. Tanto la clase de prácticas como la de teoría tenían los mismos campos y, lo único que he hecho para diferenciarlas es añadir un campo al modelo para indicar si una clase es de prácticas o o no. De hecho, con esta definición del modelo he podido definir clases que son a la vez de teoría y de prácticas. Por ejemplo, las prácticas de la asignatura \textit{Álgebra Lineal y Métodos Discretos} del Grado en Ingeniería Informática pueden hacerse en las aulas de la planta 1, al igual que otras tantas asignaturas. Pero todas las clases de teoría que se imparten en tercero y en cuarto curso del Grado en Ingeniería Informática son en la planta 1 también. Por tanto, el campo \texttt{ispractice} puede tomar los valores \texttt{Yes}, \texttt{No} y \texttt{Both}


    \item \textbf{Grupo}: en este modelo, guardo todos los datos relativos a un grupo, además de los cuatrimestres en los que ``existe'' un grupo. Esto es necesario debido a que hay grupos que sólo existen en un determinado cuatrimestre. Por ejemplo, los grupos de tercero del Grado en Ingeniería Informática troncales sólo existen en el primer cuatrimestre y los grupos de tercero del Grado en Ingeniería Informática sólo existen en el segundo. 

Definiendo los cuatrimestres en los que existe un grupo he utilizado otra utilidad de \texttt{Django}, el \texttt{validate\_comma\_separated\_integer\_list}. En verdad, este campo no es más que un string, pero que a la hora de ser guardado comprueba que encaje con la siguiente expresión regular:

\mint{text}|\d+(,\d+)*|

Es decir, una serie de números separados por comas. 

Soy consciente de que en este caso sí que estoy rompiendo la primera forma normal de bases de datos, ya que en este caso \texttt{Django} no crea una tabla especial para albergar este tipo de relación. Aún así, debido a su poca embergadura, decidí dejarlo así. Además, desde Python me ha resultado mucho más cómoda esta solución, pues es bastante fácil extraer una lista a partir de un dato en este formato, sólo hay que llamar a la función \texttt{split}:

\mint{python}|semester.split(',')|

\end{enumerate}

Un último detalle sobre la definición de la base de datos. \texttt{Django} añade las claves primarias numéricas (IDs) automáticamente. Aunque el usuario puede añadir una clave primaria a mano, lo mejor es abstraerse de eso y dejar que el ORM de \texttt{Django} se encargue. Así, las definiciones de nuestros modelos se parecerán más aún a una clase Python que a una tabla SQL.

Una vez tenemos nuestros modelos definidos, pasamos a activarlos. Para ello, hacemos una migración de la base de datos:

\begin{minted}{shell-session}
$ python manage.py makemigrations timetables
Migrations for 'timetables':
  timetables/migrations/0001_initial.py:
    - Create model Subjects
    - Create model Groups
    - Create model Classroom
    - Add field classroom to subject
    - Add field classroom to group
\end{minted}

Cuando se ejecuta el comando \texttt{makemigrations}, \texttt{Django} toma nota de los cambios que hemos hecho en la base de datos (en este caso, hemos añadido nuevos modelos) y guarda dichos cambios como una \textit{migración}. Tal y como se ha dicho antes, las migraciones son los cambios que se van haciendo a la base de datos. Lo bueno de estas migraciones es que se pueden modificar y leer de forma clara. Pero no vamos a entrar en eso ahora.

Una vez hemos guardado los cambios en la base de datos, ahora hay que hacer efectivos dichos cambios:

\begin{minted}{shell-session}
$ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, timetables, sessions
Running migrations:
  Rendering model states... DONE
  Applying timetables.0001_initial... OK
\end{minted}

El comando \texttt{migrate} toma todos las migraciones que no se hayan aplicado aún (\texttt{Django} controla esto usando una tabla especial en la base de datos llamada \texttt{django\_migrations}) y las aplica a la base de datos.

La ventaja de usar migraciones es que permiten al usuario hacer cambios en la estructura de la base de datos sin la necesidad de eliminar la base de datos o tablas y sin perder datos. El lector puede preguntarse, ¿por qué son comandos separados? Sencillo, las migraciones (es decir, el historial de cambios en la base de datos) pueden subirse a un sistema de control de versiones y pueden ser usadas por otros desarrolladores y en producción.

\subsection{Guardando información en la base de datos}
A la hora de decidir cómo el usuario iba a almacenar en la base de datos toda esta información me estuve planteando varias alternativas. Desde el primer momento descarté que el usuario lo hiciera a mano, ya que esto puede llegar a ser una tarea muy engorrosa. Lo ideal hubiera sido que el sistema se pudiera conectar a la base de datos de la Universidad de Granada para importar de ahí información actualizada. Esta opción fue rápidamente descartada por el tutor, ya que no es fácil conseguir acceso a una base de datos con información tan valiosa. Otra opción que tuve en mente fue importar en la base de datos del programa los datos exportados desde las bases de datos de la Universidad de Granada en un formato estándar, como por ejemplo; XML, JSON o CSV. Al igual que antes, esta y cualquier otra opción que supusiera conectarse o pedir datos a la Universidad de Granada se descartó.

Así que finalmente decidí hacer un script que, usando la API de \texttt{Django} leyera información de los CSVs que hicimos con los datos y los guardase en la base de datos. Esto tiene ciertas ventajas, como por ejemplo, la \textbf{flexibilidad} que da. Permite al usuario guardar los datos de forma muy sencilla: con un simple CSV. Y si el usuario, por cualquier razón, tiene los datos en otro formato, bastaría con modificar dicho script o hacer uno propio. Incluso, si finalmente este proyecto es usado por la \textit{Universidad de Granada}, se podría hacer un script propio que guardase la información. 

Lo más importante de todo es no obligar al usuario a guardar los datos en un determinado formato, sino dejarlo elegir. 

Por supuesto, soy consciente de que esto de hacer un script que lea los datos desde un CSV y los guarde en una base de datos usando la API de \texttt{Django} no es algo que cualquier usuario pueda comprender o modificar. Sino que el proceso de instalación y de importación de los datos debe ser hecho por un usuario avanzado o un técnico, que le deje al usuario todo listo para empezar a trabajar. Como estos datos no es algo que se suela cambiar mucho (no todos los días se añaden nuevas clases a un edificio ni nuevas asignaturas a un plan de estudios), se puede usar el \textbf{Administrador de \texttt{Django}} para hacer pequeñas modificaciones. Sobre ésto último hablaremos más adelante.

\subsubsection{Sobre el script para guardar la información}
Antes he hablado sobre un script que he hecho para importar datos desde unos CSVs. Me gustaría detallar más sobre dicho script, pues seguro que resultará de utilidad al lector. Dicho script es dinámico, es decir, no tiene escrito en ninguna línea de su código los nombres de las clases \texttt{Django} que tiene que instanciar. El script recibe como parámetro dichos nombres. Así, nos serviría el mismo script para guardar sólo las asignaturas o para guardar tanto las asignaturas como las clases. De hecho, hice el script con la intención de usarlo en futuros proyectos.

Aunque sea muy práctico el hecho de que el script instancie las clases que el usuario le pasa por parámetro de forma dinámica, lo cierto es que hace que el código sea poco legible. No se sabe muy bien qué clase está instanciando ni qué variables está añadiendo a dicha clase en cada momento. Esto puede hacer que, cuando un usuario se disponga a modificar el script, tenga que emplear algo más de esfuerzo en dicha tarea. Por ello, me gustaría dejar documentado su funcionamiento.

Para llamar al script y poder guardar todos los datos (clases, asignaturas y grupos) hay que ejecutar el siguiente comando:

\begin{minted}[breaklines, breakafter=d]{shell-session}
$ python store_csv.py ../Dataset/classrooms.csv Classroom ../Dataset/subjects.csv Subjects ../Dataset/groups.csv Groups
\end{minted}

Es decir, recibe como parámetros una lista donde el primer elemento es el archivo CSV con los datos y, el segundo, el modelo \texttt{Django} que instancia.

Nada más empezar el script tiene una lista de parámetros con la siguiente estructura:

\begin{displaymath}
    \Bigg[path\_csv\_class_1, class_1, \ldots, path\_csv\_class_n, class_n \Bigg]
\end{displaymath}

Pero, por comodidad, lo primero que hace es tranformarla en una lista de tuplas:

\begin{displaymath}
    \Bigg[(path\_csv\_class_1, class_1), \ldots, (path\_csv\_class_n, class_n) \Bigg]
\end{displaymath}

A partir de ahí, itera sobre la lista resultante. En primer lugar, guarda los datos del CSV en un \texttt{pandas} \textit{Dataframe} (\cite{dataframe}). A continuación, itera sobre cada fila de la tabla e instancia un objeto de la clase $class_i$. Es importante recalcar, que el objeto se instancia a partir de un string con su nombre. Una vez instanciado, se le dan valor a cada uno de sus atributos usando los nombres de las columnas de la tabla del \textit{Dataframe}. Por tanto, si el usuario tiene intención de modificar esta estructura, debe tener en cuenta que las variables del CSV deben llamarse igual que los atributos del modelo.

\subsection{El administrador de \texttt{Django}}
Previamente se ha comentado que, en caso de que alguna pequeña modificación en algún dato fuese necesaria, se puede hacer a través del administrador de \texttt{Django}. Dicho administrador, permite borrar, modificar y añadir nuevos datos a través de una interfaz web muy amigable.

Para ello, hay que seguir varios pasos muy sencillos:
\begin{enumerate}
\item En primer lugar, hay que crear un superusuario para poder acceder al panel de administración. Esto se hace a través del siguiente comando:

\begin{minted}{shell-session}
$ python manage.py createsuperuser       
Username (leave blank to use 'marta'): 
Email address: 
Password: 
Password (again): 
Superuser created successfully.
\end{minted}

Si tratamos de poner una contraseña demasiado común, se producirá un error y tendremos que elegir otra:

\begin{minted}{shell-session}
$ python manage.py createsuperuser
Username: admin
Email address: 
Password: 
Password (again): 
This password is too short. It must contain at least 8 characters.
This password is too common.
Password: ^C
Operation cancelled.
\end{minted}

\item Una vez creado un usuario, debemos indicarle al administrador los modelos que hemos hecho. Para ello, modificamos el fichero \texttt{timetables/admin.py} y registramos los modelos \texttt{Django} que hemos definido. Por ejemplo, para registrar el modelo de asignaturas bastaría con añadir la siguiente línea de código:

\mint{python}|admin.site.register(Subjects)|

\item A continuación, arrancamos el servidor de desarrollo (con el que se hizo el \textit{hola mundo} anteriormente):

\begin{minted}{shell-session}
$ python manage.py runserver
\end{minted}

\item Y, por último, accedemos en nuestro navegador a la URL \texttt{http://127.0.0.1:8000/admin/}. Al acceder, veremos la pantalla de la \hyperref[djangoadminpanel]{Figura \ref*{djangoadminpanel}}.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/djangoadminpanel}
\caption{Pantalla inicial del panel de administración}
\label{djangoadminpanel}
\end{figure}

\end{enumerate} 

Por ejemplo, si a la asignatura \textit{Nuevos Paradigmas de Interacción} del \textit{Grado en Ingeniería Informática} se le añadiese una hora más de prácticas, se podría modificar tal y como se ve en la \hyperref[djangoadminmodify]{Figura \ref*{djangoadminmodify}}.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/djangoadminmodify}
\caption{Panel para modificar la información de una asignatura}
\label{djangoadminmodify}
\end{figure}

Soy consciente de que sería una buena idea personalizar un poco la interfaz del administrador, para que sea más parecida a la del horario. Esto le daría al usuario la sensación de seguir dentro del programa y no la sensación de estar usando uno diferente. De hecho, una de las cosas a mejorar en el fururo sería esta interfaz, simplificándola más aún y dándole una estética más acorde al resto del proyecto.

\subsection{Definiendo las funciones del servidor: las urls de \texttt{Django}}
Cuando uno hace un programa en C, define en un archivo las cabeceras de las distintas funciones que componen su programa. Este proceso requiere haber definido previamente qué funciones se necesitan y, declarándolas de esta forma, el programador puede abstraerse y quedarse sólo en la definición de la misma.

Algo parecido pasa en \texttt{Django}, con la diferencia de que en nuestro caso no tenemos unas funciones que implementar y una cabecera. Tenemos un sitio web plagado de enlaces en los que el usuario va a hacer click. Cada enlace, representa una funcionalidad de la aplicación que necesita su respectiva implementación.

Ahí es donde entran en juego las URLs de \texttt{Django}. Dichas URLs se definen en el archivo \texttt{urls.py}. Hay dos archivos \texttt{urls.py} diferentes:
\begin{enumerate}[---]
    \item El archivo de URLs del proyecto.
    \item El archivo de URLs de la app.
\end{enumerate}

El primero, corresponde al archivo de URLs del proyecto en concreto y el segundo, al de la app. Este último no se crea por defecto cuando ejecutamos el comando \texttt{startapp} sino que hay que crearlo a mano. La forma correcta de trabajar con ambos ficheros es definir todas las URLs relativas a la app dentro del fichero \texttt{urls.py} de la app y, una vez definidas, importarlas dichas URLs en el fichero \texttt{urls.py} del proyecto. Así, si tenemos varias apps que se ejecutan en un mismo proyecto, nuestro código será mucho más legible y organizado. 

También es importante hablar sobre el formato en el que se definen las URLs. Se definen como \textbf{expresiones regulares}. Así, dentro de una misma acción podemos englobar muchos enlaces. Por ejemplo, imaginemos por un momento que estamos haciendo un blog. En un blog, hay un enlace para cada entrada que se está escribiendo, en dicho enlace suele incluirse información como el ID de la entrada, su fecha o el título para diferenciar cada enlace a cada entrada del blog de las otras entradas. ¿Se tendría que definir entonces un enlace para cada entrada? ¡No! (¡Vaya locura!) Simplemente sería necesario definir una expresión regular con el formato de dicha URL. Si nuestro blog incluyese por ejemplo una parte para escribir nuevas entradas, el formato de la URL para acceder a esta parte sería diferente al formato de URL para acceder a una entrada ya escrita. Así de sencillo se definen las ``cabeceras'' de funciones en \texttt{Django}. Por último, cuando definimos una expresión regular, el text que haga \textit{matching} con la expresión regular se pasará como parámetro a nuestro servidor.

Vamos a detallar el funcionamiento de las URLs poniendo de ejemplo el proyecto del horario realizado. Para ello, debemos recordar los esquemas iniciales que hice sobre la interfaz. 

\subsubsection{La pantalla inicial}
Nada más iniciar la app, se muestra un pequeño formulario con tres campos. Este es el \texttt{index.html} de toda la vida. En este caso, no quiero poner nada más que la URL del servidor en el navegador para acceder a esta pantalla inicial. Por tanto, la primera URL a definir es la URL vacía.

\begin{minted}{python}
url(r'^$', views.index, name='index'),
\end{minted}

El símbolo $\land$ se utiliza para indicar el comienzo de la expresión regular y el símbolo $\$$, para indicar el final. Por tanto, en este caso al estar ambos símbolos juntos, se indica que entre el comienzo y el final no hay nada más que vacío.

¿Qué significa lo que hay justo detrás de la expresión regular? \texttt{views.index} es la llamada que se ejecutará en el servidor cuando se reciba una petición en dicha URL y el parámetro \texttt{name}, define el nombre de la URL. Este nombre es el que se utilizará para hacer referencia a la URL desde cualquier parte del proyecto pero, en especial, desde las plantillas de \texttt{Django} que se explicarán más adelante.

En la pantalla inicial, había un botón para enviar al servidor los parámetros del horario que se desea realizar. Y nada más. Por tanto, para esta pantalla inicial debemos definir una acción o botón (URL) que al ser pulsado, mande al servidor los parámetros. Por ejemplo, como lo que hacemos en este caso es enviar información al servidor, podemos definir una URL llamada \texttt{senddata}:

\begin{minted}{python}
url(r'^senddata/$', views.senddata, name='senddata'),
\end{minted}

En este caso, no se ha definido ninguna expresión regular dentro de la URL porque la función \texttt{views.senddata} no recibe ningún parámetro. Los datos que se introducen en el formulario inicial, se envían al servidor sí pero el cómo se detallará más adelante. Por ahora sólo debemos saber que no se envían en forma de parámetro en la URL.

\subsubsection{La pantalla para mostrar los horarios}
En esta pantalla tenemos dos enlaces: el primero, es un botón que genera el horario en PDF y el segundo, es un \textit{dropdown} que permite seleccionar el grupo que queramos y ver su horario.

El enlace para generar el horario en PDF se define exactamente igual que el enlace para enviar los parámetros del horario al servidor, ya que no recibe ningún parámetro especial que necesite ser definido en forma de expresión regular:

\begin{minted}{python}
url(r'^pdf/$', views.pdf, name='pdf')
\end{minted}

Ahora bien, el \textit{dropdown} que permite elegir grupo sí: 

\begin{minted}{python}
url(r'^showdata/(?P<groupname>\w+)$', views.showdata, name='showdata'),
\end{minted}

En este ejemplo, se ve bastante claro cómo se define una expresión regular en una URL. En primer lugar, debemos señalar que dicha expresión regular es un parámetro, para ello, usamos los carácteres \texttt{?P}. A continuación, debemos indicar el nombre del parámetro que en este caso es el nombre del grupo \texttt{<groupname>} y, por último, la expresión regular que define dicho parámetro. En este caso, como el nombre de un grupo puede estar formado tanto por carácteres como por números, he usado la expresión regular \texttt{$\setminus$w+} (\textit{word}). 

Así, para ver el horario del grupo $1^{\circ}$ A, tendríamos que acceder a la siguiente URL \texttt{<URL\_SERVIDOR>/showdata/1A} y para ver el horario del grupo $3^{\circ}$ C, \texttt{<URL\_SERVIDOR>/showdata/3C}.

\subsubsection{Importando las URLs en de la app en el proyecto}
Como se dijo anteriormente, hay dos tipos de ficheros \texttt{urls.py}: el que define las URLs de la app y el que define las URLs del proyecto. Acabamos de definir el fichero de URLs de nuestra app pero, ¿cómo se importa ese fichero a nuestro proyecto? ¡En una sola línea de código!

\begin{minted}{python}
url(r'^', include('timetables.urls', namespace="timetables")),
\end{minted}

En este caso, le indicamos a nuestro proyecto una expresión regular que abarca el resto de expresiones regulares de la app. Como se dijo antes, cuando se definió la URL de la pantalla inicial, queremos que con poner la URL del servidor en el navegador ya nos aparezca la pantalla inicial. Por eso, también aquí se usa una expresión regular vacía, pero con una diferencia, en este caso no se añade el símbolo $\$$. ¿Por qué? Porque la URL aún no ha acabado, sino que a esta expresión regular se le concatenarán las expresiones regulares que se importan ejecutando la función \texttt{include}. 

Esto tiene una gran comodidad: si tuviésemos varias apps, podríamos englobar toda su funcionalidad bajo una URL común. En este caso, todas las URLs de nuestra aplicación se engloban en una URL vacía y todas las URLs del panel de administración de \texttt{Django} se engloban bajo la URL \texttt{admin/}. 

Además, si en el futuro añadimos más funcionalidad al proyecto y la parte del horario pasase a ser algo secundario, con sólo cambiar una expresión regular podríamos cambiar la URL para acceder a la funcionalidad del proyecto y dejar libre el \texttt{index.html}.

\subsection{Definiendo el servidor: las vistas de \texttt{Django}}
