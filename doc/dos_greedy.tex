\chapter{Segunda aproximación Greedy}
Para resolver los problemas de la primera aproximación realizada, se ha desarrollado un segundo algoritmo greedy. A esta segunda aproximación se le ha añadido un algoritmo previo que sirve para hacer la estructura del horario y cuyo objetivo es minimizar la ocupación de los laboratorios de prácticas.

\section{Preasignación de horas}
En esta fase lo único que se decide es qué horas serán de prácticas y cuáles serán de teoría sin asignar ninguna asignatura en concreto. El objetivo de esta fase de preasignación es minimizar la ocupación de los laboratorios de prácticas y evitar así que se saturen.

Por sencillez, el algoritmo recibe como parámetro una franja horaria (mañana o tarde) por lo que antes de empezar debe filtrar los grupos que pertenecen a dicha franja horaria. Una vez filtrados empieza a iterar sobre todos los cursos. 

En primer lugar, calcula las horas de teoría y de prácticas que tiene cada curso y, después, calcula el número total de horas de prácticas que hay en los laboratorios. Por ejemplo, si los laboratorios están abiertos cinco días a la semana y cuatro horas al día tendríamos un total de 20 horas. Como cada turno de prácticas tiene dos horas, nos quedarían un total de diez turnos de prácticas por asignar. Si, por ejemplo, tuviésemos que asignar doce turnos de prácticas, tendríamos que elegir de forma aleatoria dos turnos que se repetirían. Debe ser de forma aleatoria para que los turnos ``repetidos'' no coincidan en los distintos cursos y se saturen los laboratorios un día en concreto.

Después, el algoritmo empieza a iterar sobre cada grupo de ese curso y va asignando horas de prácticas y teoría en los huecos ``libres''. Para saber qué huecos están libres se usa una matriz auxiliar que registra qué horas son de prácticas en cada curso.

\subsection{Pseudocódigo del algoritmo}
El siguiente pseudocódigo refleja de forma más clara el funcionamiento del algoritmo.

\newpage
\begin{pseudocode}{GreedyEstructura}{turno}
\label{greedyestructura}
filtro\_grupos \GETS \CALL{FiltrarGrupos}{turno}\\
principio \GETS \CALL{ComienzoFranja}{turno}\\
final \GETS \CALL{FinalFranja}{turno}\\
\FOREACH c \in cursos \DO
\BEGIN
    filtro\_cursos \GETS \CALL{FiltrarGruposCurso}{curso, filtro\_grupos}\\
    h\_lab \GETS \CALL{CalcularHorasPracticasCurso}{curso}\\
    h\_week \GETS dias\_semana * n\_turnos\\

    \IF h\_lab > h\_week \THEN
	    	dias\_rep \GETS \CALL{CalcularTurnosRepetidos}{ }\\
    \ELSE 
      dias\_rep \GETS \emptyset\\

   	tabla\_lab \GETS \CALL{Matriz}{dias\_semana, n\_turnos}\\

   	\FOREACH g \in filtro\_cursos \DO
   	\BEGIN
   		teoria \GETS \CALL{CalcularHorasTeoria}{g}\\
   		lab \GETS \CALL{CalcularHorasLab}{g}\\

   		\FOR hora \GETS 0 \TO final; i+=2 \DO
   		\BEGIN
   		   \FOR dia \in SEMANA \DO
           \BEGIN
                \IF \NOT tabla\_lab[hora, dia] \AND lab \ge 2 \THEN
                \BEGIN
                    \CALL{AsignarEstructura}{hora, dia, L}\\
                    tabla\_lab[hora, dia] = True\\
                    tabla\_lab[hora + 1, dia] = True\\
                    lab \GETS lab - 2\\
                \END
                \ELSEIF tabla\_lab[hora, dia] \AND lab \ge 2 \AND (dia, hora) \in dias\_rep \THEN
                \BEGIN
                    \CALL{delete}{dias\_rep(dia, hora)}\\
                    \CALL{AsignarEstructura}{hora, dia, L}\\
                    lab \GETS lab - 2\\
                \END
                \ELSEIF tabla\_lab[hora, dia] \AND teoria \ge 2 \THEN
                \BEGIN
                    \CALL{AsignarEstructura}{hora, dia, T}\\
                    teoria \GETS teoria - 2\\
                \END
                \ELSEIF teoria \ge 2 \THEN
                \BEGIN
                    \CALL{AsignarEstructura}{hora, dia, T}\\
                    teoria \GETS teoria - 2\\
                \END
                \ELSEIF lab \ge 2 \THEN
                \BEGIN
                    \CALL{AsignarEstructura}{hora, dia, L}\\
                    lab \GETS lab - 2\\
                \END
                \ELSEIF teoria = 1 \THEN
                \BEGIN
                  \CALL{AsignarEstructura}{hora, dia, T}\\
                  teoria \GETS teoria - 1\\
                \END
                \ELSEIF lab = 1 \THEN
                \BEGIN
                  \CALL{AsignarEstructura}{hora, dia, L}\\
                  lab \GETS lab - 1\\
                \END
                \ELSE \CALL{break}{}
           \END
   		\END
   	\END
\END
\end{pseudocode}

\section{Asignación de horas de teoría}
Esta segunda versión del algoritmo de asignación de horas de teoría utiliza como base la estructura hecha por el algoritmo de preasignación. Así, sólo tiene permitido asignar horas en los huecos que estén marcados como \texttt{T} en la matriz de estructura. Usando esto como base y un diccionario con las horas por asignar de cada asignatura, el algoritmo distingue varios casos diferentes:

\begin{enumerate}[---]
  \item Si la hora actual no se corresponde a una de teoría en la matriz de estructura, el algoritmo no hace nada.
  \item Si la hora actual sí es de teoría y además la asignatura a asignar tiene más de dos horas pendientes por asignar, se crea un bloque de dos horas con dicha asignatura.
  \item Si la hora actual sí es de teoría pero la asignatura a asignar sólo tiene una hora más por asignar, el algoritmo trata de buscar otra con la que hacer un bloque de dos. En el caso de no existir, se asignaría esa hora únicamente.
\end{enumerate}

Cuando a una asignatura no le quedan más horas por asignar, se elimina automáticamente de la lista de asignaturas por asignar. El algoritmo pasa al siguiente grupo cuando dicha lista se queda vacía.

\subsection{Comparación con la primera versión}
En comparación con la primera versión, hay bastantes cosas que hemos mejorado:

\begin{enumerate}[$\bullet$]
  \item En la versión anterior, si no se conseguía hacer un bloque de dos con dos horas sueltas, el algoritmo o bien ciclaba o bien dejaba huecos en el horario, dando lugar a una estructura no deseada.
  \item En consecuencia, el algoritmo es más rápido que el anterior desarrollado.
  \item Usando el algoritmo de preasignación, hemos conseguido que el código sea mucho más sencillo y legible.
  \item También, el algoritmo ha perdido esa alta diversidad que tenía la versión original puesto que en la nueva versión se ha acotado mucho la estructura del algoritmo y el espacio de búsqueda.
\end{enumerate}

En conclusión, aunque el algoritmo haya perdido su diversidad original, hemos ganado tanto en eficiencia como en calidad.

\subsection{Pseudocódigo del algoritmo}
El siguiente pseudocódigo refleja de forma más clara el funcionamiento del algoritmo.

\begin{pseudocode}{GreedyTeoria}{ }
\label{greedyteoria}
\FOREACH g \in grupos
\BEGIN
  subject\_list \GETS \CALL{ObtenerListaAsignaturas}{g}\\
  \CALL{Barajar}{subject\_list}\\
  horas \GETS \CALL{DiccionarioHoras}{subject\_list}\\
  s \GETS 0\\

  \IF g.turno = M \THEN
  \BEGIN
    empezar \GETS 0 \\
    acabar \GETS \frac{horas\_dia}{2}\\
  \END
  \ELSE 
  \BEGIN
    empezar \GETS \frac{horas\_dia}{2}\\
    acabar \GETS horas\_dia\\
  \END\\

  \FOR h \GETS empezar \TO acabar; h+=2\\
  \BEGIN
    \FOR d \GETS 0 \TO W_d
    \BEGIN
      \IF subject\_list = \emptyset \THEN
      \BREAK\\

      \ELSEIF \NOT (\CALL{EsTeoria}{g, h, d} \AND \\ \;\;\; \CALL{EsTeoria}{g,h+1,d}) \THEN
      \BEGIN
        remove \GETS \FALSE\\
        asignado \GETS \FALSE\\
      \END\\

      \ELSEIF \CALL{EsTeoria}{g, h, d} \AND \\ \;\;\; horas[subject\_list[s]] \geq 2 \THEN
      \BEGIN
        eliminar \GETS \CALL{AsignarCeldaT}{g,h,d,2}\\
        asignado \GETS \TRUE\\
      \END\\

      \ELSEIF \CALL{EsTeoria}{g, h, d} \AND \\ \;\;\; horas[subject\_list[s]] = 1 \THEN
      \BEGIN
        eliminar \GETS \CALL{AsignarCeldaT}{g,h,d,1}\\
        asignado \GETS \TRUE\\
      \END\\
      \ELSEIF \CALL{EsTeoria}{g, h+1, d} \AND \\ \;\;\; horas[subject\_list[s]] = 1 \THEN
      \BEGIN
        eliminar \GETS \CALL{AsignarCeldaT}{g,h+1,d,1}\\
        asignado \GETS \TRUE\\
      \END\\

      \IF eliminar \THEN \CALL{EliminarAsignaturasCero}{ }\\
      \ELSE s = s+1 \pmod{subject\_list.size()}\\
    \END
  \END 
\END
\end{pseudocode}
